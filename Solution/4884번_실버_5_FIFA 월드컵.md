# 4884번 FIFA 월드컵

## 링크

[4884번: FIFA 월드컵 (acmicpc.net)](https://www.acmicpc.net/problem/4884)

## 제약 조건

| 제약 조건명 |   값    |
| :---------: | :-----: |
|  시간 제한  |   1초   |
| 메모리 제한 |  128MB  |
|  정답 비율  | 28.744% |

## 접근

조합의 개념과 등비수열의 합에 대해서 알고 있다면 기반이 되는 논리 자체는 간단하게 나온다. 주의해야 할 점은, 입력의 제약 조건에 있는 다음 구절이다.

> G > 0는 그룹의 수, T는 각 그룹을 구성하는 팀의 수, A는 각 조에서 토너먼트로 진출하는 팀의 수, D는 조별 리그를 거치지 않고 바로 토너먼트로 진출하는 팀의 수이다. 항상 0 < A ≤ T이고, 네 숫자는 <img src="./assets/img.png" alt="img"  />을 넘지 않는다.

이 말은 결괏값들을 계산하는데 있어서 int보다 큰 자료형을 사용하는 것이 좋다는 것을 의미한다. 만약 입력으로 받는 네 수 중에서 두 수를 곱하기만 하더라도, 값을 표시하기 위해 필요한 비트수는 32비트를 넘어갈 것이다. 따라서 int를 사용할 경우, 최악의 경우에는 오버플로우로 인해서 정상적인 값이 출력되지 않을수도 있다는 것을 염두에 두고 문제를 풀어야 한다.

먼저 토너먼트에서 이루어지는 경기 수를 구해보자. 토너먼트에서 치루어지는 경기수는 등비수열의 합 공식을 이용해서 계산할 수 있다. 예를 들어, 16강의 경우는 8번 경기를 치르고, 8강전의 경우는 4번 경기를 치르고... 이런식으로 가다가 마지막 결승전에서 1번의 경기를 치르고 끝난다. 이는 등비수열의 합 공식을 통해서 계산할 수 있다.

![vme_img_13052024_165716](./assets/vme_img_13052024_165716.png)

여기서, S는 등비수열의 합, a는 첫 번째 항, r은 공비, n은 항의 수를 나타낸다. 이제 남은 것은 n을 알아낸 다음에, 위 식에 값들을 대입하면 된다.

그런데 여기서 한가지 재미있는 것은, 몇 가지 케이스를 계산하다보면 한 가지 규칙성을 찾을 수 있다. 토너먼트에서 이루어지는 경기 수는 언제나 진출한 팀의 수보다 1이 작다. 예를 들어, 16강전으로 시작하는 경우는 15번의 경기가, 32강전으로 시작하는 경우는 31번의 경기가 치루어진다! 그렇다면 우리는 이 규칙성을 활용해서 계산을 좀 더 간단하게 만들 수 있다. 바로, 진출하는 팀의 수  - 1을 한 값이 토너먼트에서 이루어지는 경기 수라고 하는 것이다.

그렇다면 이제 총 경기수를 구하는 데 있어서 남은 것은 조별 리그에서의 경기 수를 계산하는 것이다. 조별 리그에서의 경기 수를 계산하는 것은 간단하게 생각해 볼 수 있다. 먼저, 각 조에서는 모든 팀이 서로 한 번씩 경기를 수행한다. 그리고 이 경우에서, 각 조들끼리 누구와 먼저 경기를 하는지는 중요하지 않다. 단순히 경기를 한다는 것이 중요하다. 그렇다면 이 경우는 한 조의 팀들 중에서 2개 팀으로 이루어질 수 있는 조합을 찾아내는 것과 같다. 따라서, 계산 식은 다음과 같다.

![vme_img_13052024_170647](./assets/vme_img_13052024_170647.png)

이제 여기에 G를 곱하기만 하면 우리는 조별 리그에서 치루어지는 경기 수를 알 수 있다. 그렇다면 총 경기수는 두 결괏값을 더하기만 하면 된다.

그렇다면, 이제 Y(추가되어야 하는 팀의 수)를 계산해보자. 먼저 토너먼트에 진출하는, 보정 전의 팀 수는 단순히 계산할 수 있다. 각 조당 진출할 수 있는 팀의 수와 조의 수를 곱하고, 거기에다가 D를 더하면 된다. 그런데, 여기서 추가로 진출해야 하는 팀은 몇 팀일까? 가장 가까운 2의 승수에서 보정 전의 팀을 제외한다. 가장 가까운 2의 승수가 실제로 토너먼트에서 경기를 치르는 팀의 수이므로 이 수를 기억한다.

가장 가까운 2의 승수를 계산하는 의사코드는 다음과 같다.

```pascal
입력 : 보정 전 팀의 수 BeforeTeam
출력 : BeforeTeam보다 크면서 가장 beforeTeam과 가까운 팀의 수 AfterTeam

function CalibrateTeam
	local a := 1;
	while (a < BeforeTeam) do
		a := a << 1;
	end
	
	return a;
EndFunction
```

그렇다면 이제 모든 값을 계산할 수 있다. 모든 값을 계산하는 식도 알아냈고, 각 값들을 계산하는데 필요한 값들도 계산해냈다. 남은것은 단순한 코딩 뿐이다. 이 때, 주의해야 할 점은 모든 결괏값과 중간 변수 값들은 가능하면 가장 큰 타입으로 선언하는 것이 좋다. 추가적으로 메모리가 들어갈 일이 없으므로, 큰 자료형을 사용하는 것을 주저하지 않아도 괜찮다. 만약 큰 자료형으로 선언하지 않고, int형으로 한다면, 오버플로우가 발생해 올바른 계산 식임에도 불구하고 제대로 된 값이 나오지 않을 것이다. 이점을 주의하면서 코딩한다.